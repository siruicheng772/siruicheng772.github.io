(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{493:function(v,_,t){"use strict";t.r(_);var e=t(4),o=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"梳理主干流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#梳理主干流程"}},[v._v("#")]),v._v(" 梳理主干流程")]),v._v(" "),t("ol",[t("li",[v._v("从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）")]),v._v(" "),t("li",[v._v("开启网络线程到发出一个完整的http请求（这一部分涉及到dns查询，tcp/ip请求，五层因特网协议栈等知识）")]),v._v(" "),t("li",[v._v("从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）")]),v._v(" "),t("li",[v._v("后台和前台的http交互（这一部分包括http头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等）")]),v._v(" "),t("li",[v._v("单独拎出来的缓存问题，http的缓存（这部分包括http缓存头部，etag，catch-control等）")]),v._v(" "),t("li",[v._v("浏览器接收到http数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和domcontentloaded等）")]),v._v(" "),t("li",[v._v("CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC等概念）")]),v._v(" "),t("li",[v._v("JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）")]),v._v(" "),t("li",[v._v("其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）")])]),v._v(" "),t("h2",{attrs:{id:"从浏览器接收url到开启网络请求线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#从浏览器接收url到开启网络请求线程"}},[v._v("#")]),v._v(" 从浏览器接收url到开启网络请求线程")]),v._v(" "),t("p",[v._v("浏览器是多进程的，有一个主控进程，以及每一个tab页面都会新开一个进程（某些情况下多个tab会合并进程）进程可能包括主控进程，插件进程，GPU，tab页（浏览器内核）等等")]),v._v(" "),t("p",[v._v("每一个tab页都是一个浏览器内核进程，这个内核进程又是多线程的")]),v._v(" "),t("ul",[t("li",[v._v("GUI线程")]),v._v(" "),t("li",[v._v("JS引擎线程")]),v._v(" "),t("li",[v._v("事件触发线程")]),v._v(" "),t("li",[v._v("定时器线程")]),v._v(" "),t("li",[v._v("网络请求线程")])]),v._v(" "),t("p",[t("img",{attrs:{src:"E:%5Cexperience%5C%E5%86%85%E6%A0%B8.png",alt:""}})]),v._v(" "),t("p",[v._v("网络请求线程去负责解析url，比如解析到http协议，，就会新建一个网络线程去处理资源下载。")]),v._v(" "),t("h2",{attrs:{id:"开启网络线程到发出一个完整的http请求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#开启网络线程到发出一个完整的http请求"}},[v._v("#")]),v._v(" 开启网络线程到发出一个完整的http请求")]),v._v(" "),t("h3",{attrs:{id:"dns查询得到ip"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dns查询得到ip"}},[v._v("#")]),v._v(" DNS查询得到IP")]),v._v(" "),t("p",[v._v("如果输入的是域名，需要进行dns解析成ip地址，大概流程如下：")]),v._v(" "),t("ul",[t("li",[v._v("如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用host")]),v._v(" "),t("li",[v._v("如果本地没有，就向dns域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的IP")])]),v._v(" "),t("h3",{attrs:{id:"cdn"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cdn"}},[v._v("#")]),v._v(" CDN")]),v._v(" "),t("p",[v._v("cdn即为，内容分发网络，CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。")]),v._v(" "),t("h3",{attrs:{id:"tcp-ip请求："}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp-ip请求："}},[v._v("#")]),v._v(" tcp\\ip请求：")]),v._v(" "),t("p",[v._v("http的本质是tcp请求请求，三次握手建立连接，四次回收断开链接。")]),v._v(" "),t("p",[t("strong",[v._v("三次握手的步骤")])]),v._v(" "),t("p",[v._v("客户端：hello，你是server么？\n服务端：hello，我是server，你是client么\n客户端：yes，我是client")]),v._v(" "),t("p",[t("strong",[v._v("四次挥手的步骤：（抽象派）")])]),v._v(" "),t("p",[v._v("主动方：我已经关闭了向你那边的主动通道了，只能被动接收了\n被动方：收到通道关闭的信息\n被动方：那我也告诉你，我这边向你的主动通道也关闭了\n主动方：最后收到数据，之后双方无法通信")]),v._v(" "),t("p",[v._v("现在有一个问题，链接时两次握手已经可以建立链接，为什么要第三次握手？")]),v._v(" "),t("p",[t("strong",[v._v("tcp/ip的并发限制")])]),v._v(" "),t("p",[v._v("浏览器对同一域名下并发的tcp连接是有限制的（2-10个不等）")]),v._v(" "),t("p",[v._v("而且在http1.0中往往一个资源下载就需要对应一个tcp/ip请求")]),v._v(" "),t("p",[v._v("所以针对这个瓶颈，又出现了很多的资源优化方案")]),v._v(" "),t("p",[t("strong",[v._v("get和post的区别")])]),v._v(" "),t("p",[v._v("get会产生一个tcp数据包，post两个")]),v._v(" "),t("p",[v._v("具体就是：")]),v._v(" "),t("ul",[t("li",[v._v("get请求时，浏览器会把"),t("code",[v._v("headers")]),v._v("和"),t("code",[v._v("data")]),v._v("一起发送出去，服务器响应200（返回数据），")]),v._v(" "),t("li",[v._v("post请求时，浏览器先发送"),t("code",[v._v("headers")]),v._v("，服务器响应"),t("code",[v._v("100 continue")]),v._v("，")])]),v._v(" "),t("p",[v._v("浏览器再发送"),t("code",[v._v("data")]),v._v("，服务器响应200（返回数据）。")]),v._v(" "),t("h3",{attrs:{id:"为什么一定要三次握手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么一定要三次握手"}},[v._v("#")]),v._v(" 为什么一定要三次握手")]),v._v(" "),t("p",[v._v("会有这样一个问题：当A发送一个消息给B，这个消息由于网络的原因，阻塞在某个节点了，超过我们设定的超时重发时间，A就会认为这个消息丢失了，然后重新发送。")]),v._v(" "),t("p",[v._v("A和B通信完成之后，这个之前被A认为失效的信息到达了B，B认为这是一个新的链接请求，会想A再次发了确认。")]),v._v(" "),t("p",[v._v("对于A而言，上次通信已经结束了，不会理睬新的确认信息，而B会傻傻等待，这时B的时间被白白浪费，对于服务器而言，这是cpu等资源被白白浪费")]),v._v(" "),t("h2",{attrs:{id:"后台和前台的http交互"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#后台和前台的http交互"}},[v._v("#")]),v._v(" 后台和前台的http交互")]),v._v(" "),t("h3",{attrs:{id:"请求状态码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#请求状态码"}},[v._v("#")]),v._v(" 请求状态码")]),v._v(" "),t("p",[v._v("先说几个常用的：")]),v._v(" "),t("p",[v._v("200——表明该请求被成功地完成，所请求的资源发送回客户端\n304——自从上次请求后，请求的网页未修改过，请客户端使用本地缓存\n400——客户端请求有错（譬如可以是安全模块拦截）\n401——请求未经授权\n403——禁止访问（譬如可以是未登录时禁止）\n404——资源未找到\n500——服务器内部错误\n503——服务不可用")]),v._v(" "),t("p",[v._v("再列举下大致不同范围状态的意义：")]),v._v(" "),t("p",[v._v("1xx——指示信息，表示请求已接收，继续处理\n2xx——成功，表示请求已被成功接收、理解、接受\n3xx——重定向，要完成请求必须进行更进一步的操作\n4xx——客户端错误，请求有语法错误或请求无法实现\n5xx——服务器端错误，服务器未能实现合法的请求")]),v._v(" "),t("h3",{attrs:{id:"请求头响应头"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#请求头响应头"}},[v._v("#")]),v._v(" 请求头响应头")]),v._v(" "),t("p",[v._v("常用请求头：")]),v._v(" "),t("p",[v._v("Accept: 接收类型，表示浏览器支持的MIME类型\n（对标服务端返回的Content-Type）\nAccept-Encoding：浏览器支持的压缩类型,如gzip等,超出类型不能接收\nContent-Type：客户端发送出去实体内容的类型\nCache-Control: 指定请求和响应遵循的缓存机制，如no-cache\nIf-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中\nExpires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间\nMax-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中\nIf-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中\nCookie: 有cookie并且同域访问时会自动带上\nConnection: 当浏览器与服务器通信时对于长连接如何进行处理,如keep-alive\nHost：请求的服务器URL\nOrigin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私\nReferer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)\nUser-Agent：用户客户端的一些必要信息，如UA头部等")]),v._v(" "),t("p",[v._v("常用响应头：")]),v._v(" "),t("p",[v._v("Access-Control-Allow-Headers: 服务器端允许的请求Headers\nAccess-Control-Allow-Methods: 服务器端允许的请求方法\nAccess-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）\nContent-Type：服务端返回的实体内容的类型\nDate：数据从服务器发送的时间\nCache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档\nLast-Modified：请求资源的最后修改时间\nExpires：应该在什么时候认为文档已经过期,从而不再缓存它\nMax-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效\nETag：请求变量的实体标签的当前值\nSet-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端\nKeep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）\nServer：服务器的一些相关信息")]),v._v(" "),t("p",[v._v("一般来说，请求头部和响应头部是匹配分析的。")]),v._v(" "),t("p",[v._v("譬如，请求头部的"),t("code",[v._v("Accept")]),v._v("要和响应头部的"),t("code",[v._v("Content-Type")]),v._v("匹配，否则会报错")]),v._v(" "),t("p",[v._v("譬如，跨域请求时，请求头部的"),t("code",[v._v("Origin")]),v._v("要匹配响应头部的"),t("code",[v._v("Access-Control-Allow-Origin")]),v._v("，否则会报跨域错误")]),v._v(" "),t("p",[v._v("譬如，在使用缓存时，请求头部的"),t("code",[v._v("If-Modified-Since")]),v._v("、"),t("code",[v._v("If-None-Match")]),v._v("分别和响应头部的"),t("code",[v._v("Last-Modified")]),v._v("、"),t("code",[v._v("ETag")]),v._v("对应")]),v._v(" "),t("h3",{attrs:{id:"cookie以及优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cookie以及优化"}},[v._v("#")]),v._v(" cookie以及优化")]),v._v(" "),t("p",[v._v("cookie就是一种浏览器缓存，帮助客户端服务端之间的通信，一般用来进行身份校验。")]),v._v(" "),t("p",[v._v("如在登陆页面，用户登录，带着自己的账号密码，服务端接收了，会生成一个session，会生成一个sessionId返回出去，这个id相当于是服务端对应session的key，然后客户端将这个sessionId写入cookie，这样浏览器在访问同域名的页面时就会自动带上cookie，自动校验，在有效期内无需二次登录。")]),v._v(" "),t("h4",{attrs:{id:"cookie的隔离"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cookie的隔离"}},[v._v("#")]),v._v(" cookie的隔离")]),v._v(" "),t("p",[v._v("现在有这样一个问题，假设有域名A下有一个页面，依赖很多静态资源，页面加载时，请求这些静态资源时会默认带上cookie，而实际上这些静态资源不需要cookie验证，这样就造成了资源浪费。")]),v._v(" "),t("p",[v._v("解决方法：将静态资源分组，放到不同的域名下，这样主页面请求资源时时不会带上静态资源域名的cookie的。")]),v._v(" "),t("h3",{attrs:{id:"长连接与短连接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#长连接与短连接"}},[v._v("#")]),v._v(" 长连接与短连接")]),v._v(" "),t("p",[v._v("短连接：双方有数据交互，就创建一个tcp链接，数据发送完成就断开连接。http1.0默认使用短链接，没进行一次http操作就建立链接。")]),v._v(" "),t("p",[v._v("长连接：\t一个tcp链接中可以发送多个数据包，在tcp链接期间如果没有数据包发送，就双方发送检测包来维持链接。http1.1默认使用长连接，使用时会有一行Connection: keep-alive，keep-alive不会永远保持，它有一个持续时间，一般在服务器中配置（如apache），另外长连接需要客户端和服务器都支持时才有效")]),v._v(" "),t("p",[v._v("在说下http2.0，有一个新特性，多路复用，一次tcp链接可以请求多个资源。服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端），请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。")]),v._v(" "),t("h2",{attrs:{id:"解析页面流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解析页面流程"}},[v._v("#")]),v._v(" 解析页面流程")]),v._v(" "),t("p",[v._v("浏览器内核拿到内容后，渲染步骤大致可以分为以下几步：")]),v._v(" "),t("ol",[t("li",[v._v("解析HTML，构建DOM树")]),v._v(" "),t("li",[v._v("解析CSS，生成CSS规则树")]),v._v(" "),t("li",[v._v("合并DOM树和CSS规则，生成render树")]),v._v(" "),t("li",[v._v("布局render树（Layout/reflow），负责各元素尺寸、位置的计算")]),v._v(" "),t("li",[v._v("绘制render树（paint），绘制页面像素信息")]),v._v(" "),t("li",[v._v("浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上")])]),v._v(" "),t("p",[v._v("重点说一下构建render树（渲染树）")]),v._v(" "),t("h3",{attrs:{id:"渲染树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#渲染树"}},[v._v("#")]),v._v(" 渲染树")]),v._v(" "),t("p",[v._v("当DOM树和CSSOM都有了后，就要开始构建渲染树了")]),v._v(" "),t("p",[v._v("一般来说，渲染树和DOM树相对应的，但不是严格意义上的一一对应")]),v._v(" "),t("p",[v._v("因为有一些不可见的DOM元素不会插入到渲染树中，如head这种不可见的标签或者"),t("code",[v._v("display: none")]),v._v("等")]),v._v(" "),t("ol",[t("li",[v._v("计算CSS样式")]),v._v(" "),t("li",[v._v("构建渲染树")]),v._v(" "),t("li",[v._v("布局，主要定位坐标和大小，是否换行，各种position overflow z-index属性")]),v._v(" "),t("li",[v._v("绘制，将图像绘制出来")])]),v._v(" "),t("p",[v._v("如果js动态修改了dom或者css会导致重新布局（layout）或重新徐渲染（repaint）")]),v._v(" "),t("ul",[t("li",[v._v("Layout，也称为Reflow，即回流。一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树")]),v._v(" "),t("li",[v._v("Repaint，即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了")])]),v._v(" "),t("p",[v._v("回流的成本开销要高于重绘，而且一个节点的回流往往回导致子节点以及同级节点的回流，\n所以优化方案中一般都包括，尽量避免回流。")]),v._v(" "),t("p",[t("strong",[v._v("什么会引起回流？")])]),v._v(" "),t("p",[v._v("1.页面渲染初始化")]),v._v(" "),t("p",[v._v("2.DOM结构改变，比如删除了某个节点")]),v._v(" "),t("p",[v._v("3.render树变化，比如减少了padding")]),v._v(" "),t("p",[v._v("4.窗口resize")]),v._v(" "),t("p",[v._v("5.最复杂的一种：获取某些属性，引发回流，\n很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流，\n但是除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括\n（1）offset(Top/Left/Width/Height)\n(2) scroll(Top/Left/Width/Height)\n(3) cilent(Top/Left/Width/Height)\n(4) width,height\n(5) 调用了getComputedStyle()或者IE的currentStyle")]),v._v(" "),t("p",[v._v("回流一定伴随着重绘，重绘却可以单独出现")]),v._v(" "),t("p",[v._v("所以一般会有一些优化方案，如：")]),v._v(" "),t("ul",[t("li",[v._v("减少逐项更改样式，最好一次性更改style，或者将样式定义为class并一次性更新")]),v._v(" "),t("li",[v._v("避免循环操作dom，创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到window.document")]),v._v(" "),t("li",[v._v("避免多次读取offset等属性。无法避免则将它们缓存到变量")]),v._v(" "),t("li",[v._v("将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高")])]),v._v(" "),t("p",[v._v("注意：改变字体大小会引发回流")]),v._v(" "),t("h3",{attrs:{id:"资源外链的下载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#资源外链的下载"}},[v._v("#")]),v._v(" 资源外链的下载")]),v._v(" "),t("p",[t("strong",[v._v("遇到CSS样式资源")])]),v._v(" "),t("p",[v._v("CSS资源的处理有几个特点：")]),v._v(" "),t("ul",[t("li",[v._v("CSS下载时异步，不会阻塞浏览器构建DOM树")]),v._v(" "),t("li",[v._v("但是会阻塞渲染，也就是在构建render时，会等到css下载解析完毕后才进行（这点与浏览器优化有关，防止css规则不断改变，避免了重复的构建）")]),v._v(" "),t("li",[v._v("有例外，"),t("code",[v._v("media query")]),v._v("声明的CSS是不会阻塞渲染的")])]),v._v(" "),t("p",[t("strong",[v._v("遇到JS脚本资源")])]),v._v(" "),t("p",[v._v("JS脚本资源的处理有几个特点：")]),v._v(" "),t("ul",[t("li",[v._v("阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析HTML")]),v._v(" "),t("li",[v._v("浏览器的优化，一般现代浏览器有优化，在脚本阻塞时，也会继续下载其它资源（当然有并发上限），但是虽然脚本可以并行下载，解析过程仍然是阻塞的，也就是说必须这个脚本执行完毕后才会接下来的解析，并行下载只是一种优化而已")]),v._v(" "),t("li",[v._v("defer与async，普通的脚本是会阻塞浏览器解析的，但是可以加上defer或async属性，这样脚本就变成异步了，可以等到解析完毕后再执行")])]),v._v(" "),t("p",[v._v("注意，defer和async是有区别的： "),t("strong",[v._v("defer是延迟执行，而async是异步执行。")])]),v._v(" "),t("p",[v._v("简单的说（不展开）：")]),v._v(" "),t("ul",[t("li",[t("code",[v._v("async")]),v._v("是异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在"),t("code",[v._v("onload")]),v._v("前，但不确定在"),t("code",[v._v("DOMContentLoaded")]),v._v("事件的前或后")]),v._v(" "),t("li",[t("code",[v._v("defer")]),v._v("是延迟执行，在浏览器看起来的效果像是将脚本放在了"),t("code",[v._v("body")]),v._v("后面一样（虽然按规范应该是在"),t("code",[v._v("DOMContentLoaded")]),v._v("事件前，但实际上不同浏览器的优化效果不一样，也有可能在它后面）")])]),v._v(" "),t("p",[t("strong",[v._v("遇到img图片类资源")])]),v._v(" "),t("p",[v._v("遇到图片等资源时，直接就是异步下载，不会阻塞解析，下载完毕后直接用图片替换原有src的地方")])])}),[],!1,null,null,null);_.default=o.exports}}]);